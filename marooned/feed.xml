<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="/marooned/feed.xml" rel="self" type="application/atom+xml" /><link href="/marooned/" rel="alternate" type="text/html" /><updated>2024-10-15T20:54:05+01:00</updated><id>/marooned/feed.xml</id><title type="html">Marooned on Github</title><subtitle>A website for Arnaud Delobelle</subtitle><entry><title type="html">Go Contracts clash with Interfaces</title><link href="/marooned/go/generics/2020/06/21/go-against-contracts.html" rel="alternate" type="text/html" title="Go Contracts clash with Interfaces" /><published>2020-06-21T00:00:00+01:00</published><updated>2020-06-21T00:00:00+01:00</updated><id>/marooned/go/generics/2020/06/21/go-against-contracts</id><content type="html" xml:base="/marooned/go/generics/2020/06/21/go-against-contracts.html"><![CDATA[<p>I originally wrote this on the 5th of August 2019 but didn’t share it.</p>

<p>After reading about <a href="https://blog.golang.org/generics-next-steps">The Next Steps for Generics</a> on the Go Blog, which I think
are great next steps by the way, I recalled that last year shortly after the
publication of the <a href="https://github.com/golang/proposal/blob/master/design/go2draft-contracts.md">Go Contracts Proposal</a> I had written down an argument
against contract, explaining why in my view their overlap with interfaces was a
problem, and showing step by step how we could make both concepts be more
orthogonal with each other, which ends in the realisation that contracts are not
needed after all.</p>

<p>I now see some value in sharing it, even though it’s a little late, because I
think it provides a rationale for evaluating the updated interface-based
proposal against the previous contract-base one. So here it is, copy-pasted
from a file on my computer!</p>

<h2 id="non-orthogonality-in-the-draft-generics-proposal">Non-orthogonality in the draft generics proposal</h2>

<p>An example of the proposal is the <a href="https://github.com/golang/proposal/blob/master/design/go2draft-contracts.md#contract-introduction"><code class="language-plaintext highlighter-rouge">Stringer</code> contract</a>,
spelt differently to disambiguate with the interface:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">contract</span> <span class="n">StringerC</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This is inspired from the standard library <code class="language-plaintext highlighter-rouge">Stringer</code> interface:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Stringer</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In fact, any type implements the <code class="language-plaintext highlighter-rouge">Stringer</code> interface if and only if it
satisfies the <code class="language-plaintext highlighter-rouge">StringerC</code> contract! The concepts are clearly not orthogonal. I
am not implying that the contract and interface above fulfill the same role
(they don’t), I am saying that they express the same information about a type.</p>

<p>OTOH another example given in the proposal is that of a <a href="https://github.com/golang/proposal/blob/master/design/go2draft-contracts.md#mutually-referencing-type-parameters">graph contract</a>:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">contract</span> <span class="n">G</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">N</span> <span class="n">Edges</span><span class="p">()</span> <span class="p">[]</span><span class="n">E</span>
    <span class="n">E</span> <span class="n">Nodes</span><span class="p">()</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Clearly that relationship between types cannot be expressed with an interface,
because an interface is about specifying method signatures for one type only.</p>

<p>What I want to show is that it is possible to ‘factor out’ the common part of
contracts and interfaces so that:</p>

<ul>
  <li>interfaces are the only means of specifying the signature of a set of methods
for a atype.</li>
  <li>contracts are the only means of specifying relationships between types.</li>
</ul>

<h2 id="factoring-method-signature-out-of-contracts">Factoring method signature out of contracts</h2>

<p>The graph contract:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">contract</span> <span class="n">G</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">N</span> <span class="n">Edges</span><span class="p">()</span> <span class="p">[]</span><span class="n">E</span>
    <span class="n">E</span> <span class="n">Nodes</span><span class="p">()</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>can be rewritten as the combination of two contracts, each only specifying the
methods of one single generic type:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">contract</span> <span class="n">NodeC</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">N</span> <span class="n">Edges</span><span class="p">()</span> <span class="p">[]</span><span class="n">E</span>
<span class="p">}</span>

<span class="n">contract</span> <span class="n">EdgeC</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">E</span> <span class="n">Nodes</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">contract</span> <span class="n">G</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">NodeC</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>
    <span class="n">EdgeC</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now the interfaces <code class="language-plaintext highlighter-rouge">NodeC</code> and <code class="language-plaintext highlighter-rouge">EdgeC</code> express information about a type that can
be expressed by generic interfaces:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">NodeI</span><span class="p">(</span><span class="k">type</span> <span class="n">E</span><span class="p">)</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Edges</span><span class="p">()</span> <span class="p">[]</span><span class="n">E</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">EdgeI</span><span class="p">(</span><span class="k">type</span> <span class="n">N</span><span class="p">)</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Nodes</span><span class="p">()</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now if I only could express in a contract that a type should satisfy an
interface, I could express my graph contract in terms of generic interfaces. So
let’s imagine that I can write:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">contract</span> <span class="n">G</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">N</span> <span class="n">NodeI</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>  <span class="c">// This means that N implements the NodeI(E) interface</span>
    <span class="n">E</span> <span class="n">EdgeI</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>  <span class="c">// This means that E implements the EdgeI(N) interface</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If we ignore for now the case of types in contracts, I think it is clear that
every contract can be rewritten in terms of generic interfaces like the one
above. It’s pretty obvious that the process above can be applied to any
contract.</p>

<h2 id="the-case-of-types-in-contracts">The case of types in contracts</h2>

<p>According to the principle that what is about one single type should be
specified in an interface, a contract like this one:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">contract</span> <span class="n">SignedIntegerC</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">T</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span>
<span class="p">}</span>
</code></pre></div></div>

<p>should really be an interface:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">SignedIntegerI</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="kt">int</span><span class="p">,</span> <span class="kt">int8</span><span class="p">,</span> <span class="kt">int16</span><span class="p">,</span> <span class="kt">int32</span><span class="p">,</span> <span class="kt">int64</span>
<span class="p">}</span>

<span class="n">contract</span> <span class="n">SignedIntegerC</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">SignedInteger</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The above means that types that implement <code class="language-plaintext highlighter-rouge">SignedIntegerI</code> must have one of the
types listed as its underlying type.</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Sum</span><span class="p">(</span><span class="k">type</span> <span class="n">T</span> <span class="n">SignedIntegerC</span><span class="p">)(</span><span class="n">s</span> <span class="p">[]</span><span class="n">T</span><span class="p">)</span> <span class="p">(</span><span class="n">sum</span> <span class="kt">int64</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span> <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="kt">int64</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that it means that in the above we should not be able to choose
<code class="language-plaintext highlighter-rouge">SignedInterfaceI</code> as the value of <code class="language-plaintext highlighter-rouge">T</code> as the type <code class="language-plaintext highlighter-rouge">SignedInterfaceI</code> itself
does not have any of the signed integer types as its underlying type. That is a
bit strange!</p>

<h2 id="why-use-a-contract-at-all">Why use a contract at all?</h2>

<p>Say we want to implement a graph data structure using the <code class="language-plaintext highlighter-rouge">G</code> contract specified above:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">contract</span> <span class="n">G</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">N</span> <span class="n">NodeI</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
    <span class="n">E</span> <span class="n">EdgeI</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Graph</span><span class="p">(</span><span class="k">type</span> <span class="n">N</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">G</span><span class="p">)</span> <span class="k">struct</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div></div>

<p>Instead, you could just specify what interfaces the types <code class="language-plaintext highlighter-rouge">N</code> and <code class="language-plaintext highlighter-rouge">E</code> should implement:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Graph</span><span class="p">(</span><span class="k">type</span> <span class="n">N</span> <span class="n">NodeI</span><span class="p">(</span><span class="n">E</span><span class="p">),</span> <span class="n">E</span> <span class="n">EdgeI</span><span class="p">(</span><span class="n">N</span><span class="p">))</span> <span class="k">struct</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
</code></pre></div></div>

<p>In fact many of the contracts in the examples I have seen so far do not express
a relationship of the types they are a contract for. Here is an example from
the <a href="https://github.com/golang/proposal/blob/master/design/go2draft-contracts.md#metrics"><code class="language-plaintext highlighter-rouge">metrics</code> package</a>:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">contract</span> <span class="n">cmp3</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">T3</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">comparable</span><span class="p">(</span><span class="n">T1</span><span class="p">)</span>
	<span class="n">comparable</span><span class="p">(</span><span class="n">T2</span><span class="p">)</span>
	<span class="n">comparable</span><span class="p">(</span><span class="n">T3</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">key3</span><span class="p">(</span><span class="k">type</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">T3</span> <span class="n">cmp3</span><span class="p">)</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">f1</span> <span class="n">T1</span>
	<span class="n">f2</span> <span class="n">T2</span>
	<span class="n">f3</span> <span class="n">T3</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Metric3</span><span class="p">(</span><span class="k">type</span> <span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">T3</span> <span class="n">cmp3</span><span class="p">)</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">mu</span> <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
	<span class="n">m</span>  <span class="k">map</span><span class="p">[</span><span class="n">key3</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">T3</span><span class="p">)]</span><span class="kt">int</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Assuming <code class="language-plaintext highlighter-rouge">comparable</code> is an interface, using this new syntax you wouldn’t need
the contract and could just write the following.</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">key3</span><span class="p">(</span><span class="k">type</span> <span class="n">T1</span> <span class="n">comparable</span><span class="p">,</span> <span class="n">T2</span> <span class="n">comparable</span><span class="p">,</span> <span class="n">T3</span> <span class="n">comparable</span><span class="p">)</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">f1</span> <span class="n">T1</span>
	<span class="n">f2</span> <span class="n">T2</span>
	<span class="n">f3</span> <span class="n">T3</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Metric3</span><span class="p">(</span><span class="k">type</span> <span class="n">T1</span> <span class="n">comparable</span><span class="p">,</span> <span class="n">T2</span> <span class="n">comparable</span><span class="p">,</span> <span class="n">T3</span> <span class="n">comparable</span><span class="p">)</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">mu</span> <span class="n">sync</span><span class="o">.</span><span class="n">Mutex</span>
	<span class="n">m</span>  <span class="k">map</span><span class="p">[</span><span class="n">key3</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">,</span> <span class="n">T3</span><span class="p">)]</span><span class="kt">int</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It’s a matter of taste what syntax is nicer, but what is sure is that the
contract version is no more expressive.</p>]]></content><author><name></name></author><category term="go" /><category term="generics" /><summary type="html"><![CDATA[I originally wrote this on the 5th of August 2019 but didn’t share it.]]></summary></entry><entry><title type="html">Package Specialization in Go</title><link href="/marooned/go/generics/2020/06/06/go-spec2.html" rel="alternate" type="text/html" title="Package Specialization in Go" /><published>2020-06-06T00:00:00+01:00</published><updated>2020-06-06T00:00:00+01:00</updated><id>/marooned/go/generics/2020/06/06/go-spec2</id><content type="html" xml:base="/marooned/go/generics/2020/06/06/go-spec2.html"><![CDATA[<p>This is a follow-up to my <a href="/marooned//go/generics/2020/05/25/go-spec.html">inital post</a> about Go Generics.  In this post I attempt to scale back
the approach outlined there to be the simplest possible while still providing
the full power of parametrized code, and sketch the semantics more precisely.
The problem space I’m trying to explore remains the same, which is to use
interfaces as a means to write generic code in Go.</p>

<p>Headline features are:</p>
<ul>
  <li>use interfaces to express parametric types;</li>
  <li>no new keyword;</li>
  <li>the only new syntax is “package specialization”: <code class="language-plaintext highlighter-rouge">pkg(T=int, Y=*MyType).Func()</code>;</li>
  <li>generic code which doesn’t use the package specialization syntax is already
valid Go.</li>
</ul>

<h2 id="overview">Overview</h2>

<p>This proposal introduces the ability to <em>specialize</em> a package.  This is
achieved by “replacing” a set of interface types defined in that package with
some concrete types.  In this section I will go through a basic example, before
attempting to define more precisely the syntax and semantics of this feature and
then giving a more varied set of examples.  The <code class="language-plaintext highlighter-rouge">slice</code> package below defines a
<code class="language-plaintext highlighter-rouge">Reverse</code> function that reverses a slice of type <code class="language-plaintext highlighter-rouge">T</code> in place.</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">slice</span>

<span class="k">type</span> <span class="n">T</span> <span class="k">interface</span><span class="p">{}</span>

<span class="k">func</span> <span class="n">Reverse</span><span class="p">(</span><span class="n">l</span> <span class="p">[]</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="m">1</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="p">{</span>
		<span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="n">i</span><span class="o">++</span>
		<span class="n">j</span><span class="o">--</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Under this proposal, I can use this to reverse a slice of any type like this:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"github.com/arnodel/slice"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">hw</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"!dlrow ,olleH"</span><span class="p">)</span>

    <span class="c">// Type T is "specialized" to byte in the slice package</span>
    <span class="n">slice</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="kt">byte</span><span class="p">)</span><span class="o">.</span><span class="n">Reverse</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="kt">string</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>

    <span class="c">// ... means the compiler may infer the type specializations</span>
    <span class="n">slice</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="n">Reverse</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="kt">string</span><span class="p">(</span><span class="n">hw</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In particular, existing packages can now be specialized without change
(including in the standard library).  Here is an example from the <code class="language-plaintext highlighter-rouge">sort</code>
package.</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="n">sort</span>

<span class="k">func</span> <span class="n">sortStrings</span><span class="p">(</span><span class="n">l</span> <span class="p">[]</span><span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// This is different from sort.Sort(sort.StringSlice(l))</span>
    <span class="c">// because the specialized Sort function has type</span>
    <span class="c">//    func(sort.StringSlice)</span>
    <span class="c">// instead of</span>
    <span class="c">//    func(sort.Interface)</span>
    <span class="n">sort</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="n">Sort</span><span class="p">(</span><span class="n">sort</span><span class="o">.</span><span class="n">StringSlice</span><span class="p">(</span><span class="n">l</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="syntax">Syntax</h2>

<p>The only syntactical change to Go required to express this is to the <a href="https://golang.org/ref/spec#Qualified_identifiers">Qualified
Identifier</a> rule, which is
changed from the current rule</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>QualifiedIdent = PackageName "." identifier .
</code></pre></div></div>

<p>to the following rule</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>QualifiedIdent = PackageName [ PackageSpec ] "." identifier .
</code></pre></div></div>

<p>where <code class="language-plaintext highlighter-rouge">PackageSpec</code> is defined as follows (<code class="language-plaintext highlighter-rouge">AliasDecl</code> being the Go <a href="https://golang.org/ref/spec#AliasDecl">Alias
Declaration</a> rule)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>PackageSpec = "(" { AliasDecl ";" } [ "..." ] ")" .
</code></pre></div></div>

<h2 id="semantics">Semantics</h2>

<p><em>The following explanation could be made rigorous, but I think that would be at
the expense of a lot of readability so I have brushed over details
intentionally.  I have kept some form of mathematical notation though to avoid
being to verbose, although I am aware that the result is far from satisfactory</em></p>

<h3 id="package-specialization-σsigmaσ">Package specialization <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span></h3>

<p>We define a package specialization as</p>

<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mo>=</mo><mi>P</mi><mo stretchy="false">(</mo><msub><mi>I</mi><mn>1</mn></msub><mo>=</mo><msub><mi>T</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>I</mi><mi>n</mi></msub><mo>=</mo><msub><mi>U</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma = P(I_1=T_1, \ldots, I_n=U_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">U</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span></p>

<p>where</p>

<ul>
  <li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> is a package that defines public interface types <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>I</mi><mo>=</mo><msub><mi>I</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>I</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">I = I_1, \ldots, I_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> at
package scope;</li>
  <li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo>=</mo><msub><mi>T</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>T</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">T = T_1, \ldots, T_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are types defined in packages <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>P</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">P_1, \ldots, P_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>
is allowed to be the “builtin” package if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">T_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is a builtin type).</li>
</ul>

<p><strong>Example</strong>.  In the expression <code class="language-plaintext highlighter-rouge">slice(T=byte).Reverse()</code> in the previous
section, the specialization <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span> is <code class="language-plaintext highlighter-rouge">slice(T=byte)</code>.</p>

<h3 id="the-concrete-package-of-σsigmaσ">The concrete package of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span></h3>

<p>We can define the <em>concrete package</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>σ</mi></msub></mrow><annotation encoding="application/x-tex">K_\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span> as follows.</p>
<ul>
  <li>If there is a package <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi><mo>∈</mo><mo stretchy="false">{</mo><mi>P</mi><mo separator="true">,</mo><msub><mi>P</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>P</mi><mi>n</mi></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">K\in\{P, P_1, \ldots, P_n\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> so that <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> import all the
other packages in this set, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>σ</mi></msub></mrow><annotation encoding="application/x-tex">K_\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is defined to be <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span> <em>but on a
different namespace</em> (to allow dependencies between both but avoid name
clashes).</li>
  <li>Otherwise we make a unique package <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>σ</mi></msub><mo>=</mo><mi>K</mi><mo stretchy="false">(</mo><mi>P</mi><mo separator="true">,</mo><msub><mi>P</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>P</mi><mi>n</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">K_\sigma = K(P, P_1,\ldots,P_n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> which
imports all of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo separator="true">,</mo><msub><mi>P</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>P</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">P, P_1, \ldots, P_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</li>
</ul>

<p><strong>Example</strong>.  The concrete package of the specialization <code class="language-plaintext highlighter-rouge">slice(T=byte)</code>, is the
<code class="language-plaintext highlighter-rouge">slice</code> package itself as the <code class="language-plaintext highlighter-rouge">byte</code> type is builtin.</p>

<h3 id="implementation-of-kσk_sigmakσ">Implementation of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>σ</mi></msub></mrow><annotation encoding="application/x-tex">K_\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></h3>

<p>The package <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>σ</mi></msub></mrow><annotation encoding="application/x-tex">K_\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> is populated with</p>
<ul>
  <li>definitions for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>I</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">I_1, \ldots, I_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> as <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>T</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>T</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">T_1, \ldots, T_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> (this is possible
because <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>σ</mi></msub></mrow><annotation encoding="application/x-tex">K_\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> imports all of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>P</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>P</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">P_1, \ldots, P_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>);</li>
  <li>all the package-scope definitions from the original package <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> that depend on
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>I</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">I_1, \ldots, I_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>;</li>
  <li>package-scope definitions which do not depend on <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>I</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>I</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">I_1, \ldots, I_n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> are just
aliases for the original ones in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>.</li>
</ul>

<p>If this results in valid Go, then we call <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi></mrow><annotation encoding="application/x-tex">\sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span></span></span></span> a <em>valid specialization</em>.</p>

<p><strong>Example</strong>.  To implement the <code class="language-plaintext highlighter-rouge">slice(T=byte)</code> specialization, we add the
following definitions to the <code class="language-plaintext highlighter-rouge">slice</code> package, where <code class="language-plaintext highlighter-rouge">__spec__</code> represents a
namespace prefix unique to this specialization, resulting in the following
definitions.</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">__spec__T</span> <span class="o">=</span> <span class="kt">byte</span>

<span class="k">func</span> <span class="n">__spec__Reverse</span><span class="p">(</span><span class="n">l</span> <span class="p">[]</span><span class="n">__spec__T</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">:=</span> <span class="m">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="m">1</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span> <span class="p">{</span>
		<span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
		<span class="n">i</span><span class="o">++</span>
		<span class="n">j</span><span class="o">--</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="implementation-of-σssigmasσs">Implementation of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>σ</mi><mi mathvariant="normal">.</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">\sigma.S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">σ</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span></h3>
<p>Now if <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> is an identifier declared in <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span> at package scope, then <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>P</mi><mo stretchy="false">(</mo><msub><mi>I</mi><mn>1</mn></msub><mo>=</mo><mi>T</mi><mn>1</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>I</mi><mi>n</mi></msub><mo>=</mo><msub><mi>T</mi><mi>n</mi></msub><mo stretchy="false">)</mo><mi mathvariant="normal">.</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">P(I_1=T1, \ldots,
I_n=T_n).S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span> is simply an alias for <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>K</mi><mi>σ</mi></msub><mi mathvariant="normal">.</mi><mi>S</mi></mrow><annotation encoding="application/x-tex">K_\sigma.S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">σ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">.</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>.</p>

<p><strong>Example</strong>.  The expression <code class="language-plaintext highlighter-rouge">slice(T=byte).Reverse()</code> is resolved as
<code class="language-plaintext highlighter-rouge">slice.__spec__Reverse()</code>.</p>

<h2 id="examples">Examples</h2>

<p>In this section, I am trying to give simple but realistic examples of issues
that this proposal would be able to solve.  I have picked a few use cases from
the <a href="https://blog.golang.org/why-generics">Why Generics?</a> post from the Go Blog.</p>

<h3 id="a-generic-set-package">A generic <code class="language-plaintext highlighter-rouge">set</code> package</h3>

<p>Here is a simple generic <code class="language-plaintext highlighter-rouge">set</code> package.</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">set</span>

<span class="k">type</span> <span class="n">Item</span> <span class="k">interface</span><span class="p">{}</span>

<span class="k">type</span> <span class="n">Set</span> <span class="k">map</span><span class="p">[</span><span class="n">Item</span><span class="p">]</span><span class="k">struct</span><span class="p">{}</span>

<span class="k">func</span> <span class="n">New</span><span class="p">()</span> <span class="n">Set</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">make</span><span class="p">(</span><span class="n">Set</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="n">Set</span><span class="p">)</span> <span class="n">Add</span><span class="p">(</span><span class="n">x</span> <span class="n">Item</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="k">struct</span><span class="p">{}{}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="n">Set</span><span class="p">)</span> <span class="n">Remove</span><span class="p">(</span><span class="n">x</span> <span class="n">Item</span><span class="p">)</span> <span class="p">{</span>
    <span class="nb">delete</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="n">Set</span><span class="p">)</span> <span class="n">Has</span><span class="p">(</span><span class="n">x</span> <span class="n">Item</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="n">_</span><span class="p">,</span> <span class="n">ok</span> <span class="o">:=</span> <span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ok</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I can implement a generic <code class="language-plaintext highlighter-rouge">Uniq</code> function using it:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">uniq</span>

<span class="k">import</span> <span class="s">"github.com/arnodel/set"</span>

<span class="k">type</span> <span class="n">Item</span> <span class="k">interface</span><span class="p">{}</span>

<span class="k">func</span> <span class="n">Uniq</span><span class="p">(</span><span class="n">items</span> <span class="p">[]</span><span class="n">Item</span><span class="p">)</span> <span class="p">[]</span><span class="n">Item</span> <span class="p">{</span>
    <span class="n">seen</span> <span class="o">:=</span> <span class="n">set</span><span class="p">(</span><span class="n">Item</span><span class="o">=</span><span class="n">Item</span><span class="p">)</span><span class="o">.</span><span class="n">New</span><span class="p">()</span>  <span class="c">// &lt;- Specialization of set here!</span>
    <span class="k">var</span> <span class="n">uniq</span> <span class="p">[]</span><span class="n">Item</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">items</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="n">seen</span><span class="o">.</span><span class="n">Has</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">seen</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">uniq</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">uniq</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">uniq</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="generic-channel-operations">Generic channel operations</h3>

<p>This is copied almost verbatim from the
<a href="https://blog.golang.org/pipelines">Pipelines</a> post in the Go Blog.</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">package</span> <span class="n">channel</span>

<span class="k">type</span> <span class="n">T</span> <span class="k">interface</span><span class="p">{}</span>

<span class="k">func</span> <span class="n">Merge</span><span class="p">(</span><span class="n">cs</span> <span class="o">...&lt;-</span><span class="k">chan</span> <span class="n">T</span><span class="p">)</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="n">T</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">wg</span> <span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span>
    <span class="n">out</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">T</span><span class="p">)</span>

    <span class="c">// Start an output goroutine for each input channel in cs.  output</span>
    <span class="c">// copies values from c to out until c is closed, then calls wg.Done.</span>
    <span class="n">output</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">c</span> <span class="o">&lt;-</span><span class="k">chan</span> <span class="n">T</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="n">n</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">c</span> <span class="p">{</span>
            <span class="n">out</span> <span class="o">&lt;-</span> <span class="n">n</span>
        <span class="p">}</span>
        <span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">c</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">cs</span> <span class="p">{</span>
        <span class="k">go</span> <span class="n">output</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c">// Start a goroutine to close out once all the output goroutines are</span>
    <span class="c">// done.  This must start after the wg.Add call.</span>
    <span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
        <span class="nb">close</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
    <span class="p">}()</span>
    <span class="k">return</span> <span class="n">out</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It could then be used as follows to make a basic implementation of <code class="language-plaintext highlighter-rouge">tail -f</code></p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"github.com/arnodel/channel"</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">files</span> <span class="o">:=</span> <span class="n">getInputFiles</span><span class="p">()</span>
    <span class="n">inputChans</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="k">chan</span> <span class="kt">string</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">files</span> <span class="p">{</span>
        <span class="n">inputChans</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:=</span> <span class="n">getLineChannel</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="n">outputChan</span> <span class="o">:=</span> <span class="n">channel</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="kt">string</span><span class="p">)</span><span class="o">.</span><span class="n">Merge</span><span class="p">(</span><span class="n">intpuChans</span><span class="o">...</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">l</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">outputChan</span> <span class="p">{</span>
        <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">getInputFiles</span><span class="p">()</span> <span class="p">[]</span><span class="n">io</span><span class="o">.</span><span class="n">Reader</span> <span class="p">{</span>
    <span class="c">// Return the files specified on the command line.</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">getLineChannel</span><span class="p">(</span><span class="n">r</span> <span class="n">io</span><span class="o">.</span><span class="n">Reader</span><span class="p">)</span> <span class="k">chan</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="c">// Return a channel onto which lines from the reader are pushed.</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="generic-map-and-reduce-functions-on-slices">Generic <code class="language-plaintext highlighter-rouge">Map</code> and <code class="language-plaintext highlighter-rouge">Reduce</code> functions on slices</h3>

<p>Imagine I have a <code class="language-plaintext highlighter-rouge">slice</code> package that provide some slice manipulation primitives.</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">slice</span>

<span class="k">type</span> <span class="n">T</span> <span class="k">interface</span><span class="p">{}</span>
<span class="k">type</span> <span class="n">U</span> <span class="k">interface</span><span class="p">{}</span>

<span class="k">func</span> <span class="n">Map</span><span class="p">(</span><span class="n">ts</span> <span class="p">[]</span><span class="n">T</span><span class="p">,</span> <span class="n">f</span> <span class="k">func</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">U</span><span class="p">)</span> <span class="p">[]</span><span class="n">U</span> <span class="p">{</span>
    <span class="n">us</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="n">U</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ts</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">ts</span> <span class="p">{</span>
        <span class="n">us</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">us</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Reduce</span><span class="p">(</span><span class="n">ts</span> <span class="p">[]</span><span class="n">T</span><span class="p">,</span> <span class="n">f</span> <span class="k">func</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">U</span><span class="p">)</span> <span class="n">U</span><span class="p">,</span> <span class="n">u</span> <span class="n">U</span><span class="p">)</span> <span class="n">U</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">t</span> <span class="o">:=</span> <span class="n">tange</span> <span class="n">ts</span> <span class="p">{</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">u</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This package defines “generic” <code class="language-plaintext highlighter-rouge">Map</code> and <code class="language-plaintext highlighter-rouge">Reduces</code> functions.  They could be
used as is, but that wouldn’t be very useful because of the constant interface
wrapping / unwrapping that would be required.  But specializing them makes them
more universally applicable.</p>

<p>Now imagine I want to use those in my <code class="language-plaintext highlighter-rouge">vector</code> package.</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">vector</span>

<span class="k">import</span> <span class="s">"github.com/arnodel/slice"</span>

<span class="k">type</span> <span class="n">Scalar</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Add</span><span class="p">(</span><span class="n">Scalar</span><span class="p">)</span> <span class="n">Scalar</span>
    <span class="n">Mul</span><span class="p">(</span><span class="n">Scalar</span><span class="p">)</span> <span class="n">Scalar</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Vector</span> <span class="p">[]</span><span class="n">Scalar</span>

<span class="k">func</span> <span class="p">(</span><span class="n">v</span> <span class="n">Vector</span><span class="p">)</span> <span class="n">Norm</span><span class="p">()</span> <span class="n">Scalar</span> <span class="p">{</span>
    <span class="n">sq</span> <span class="o">:=</span> <span class="n">slice</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">Scalar</span><span class="p">;</span> <span class="n">U</span><span class="o">=</span><span class="n">Scalar</span><span class="p">)</span><span class="o">.</span><span class="n">Map</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="k">func</span> <span class="p">(</span><span class="n">x</span> <span class="n">Scalar</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">Mul</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">})</span>
    <span class="n">sumsq</span> <span class="o">:=</span> <span class="n">slice</span><span class="p">(</span><span class="n">T</span><span class="o">=</span><span class="n">Scalar</span><span class="p">;</span> <span class="n">U</span><span class="o">=</span><span class="n">Scalar</span><span class="p">)</span><span class="o">.</span><span class="n">Reduce</span><span class="p">(</span><span class="n">sq</span><span class="p">,</span> <span class="n">Scalar</span><span class="o">.</span><span class="n">Add</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">Sqrt</span><span class="p">(</span><span class="n">sumsq</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">// Many more functions!</span>
</code></pre></div></div>

<p>I can specialize the <code class="language-plaintext highlighter-rouge">vector.Vector</code> type to <code class="language-plaintext highlighter-rouge">Float</code></p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">vec64</span>

<span class="k">import</span> <span class="s">"github.com/arnodel/vector"</span>

<span class="k">type</span> <span class="n">Float64</span> <span class="kt">float64</span>

<span class="k">func</span> <span class="p">(</span><span class="n">x</span> <span class="n">Float64</span><span class="p">)</span> <span class="n">Add</span><span class="p">(</span><span class="n">y</span> <span class="n">Float64</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">x</span> <span class="n">Float64</span><span class="p">)</span> <span class="n">Mul</span><span class="p">(</span><span class="n">y</span> <span class="n">Float64</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Vec64</span> <span class="o">=</span> <span class="n">vector</span><span class="p">(</span><span class="n">Scalar</span><span class="o">=</span><span class="n">Float64</span><span class="p">)</span><span class="o">.</span><span class="n">Vector</span>
</code></pre></div></div>

<h3 id="mutually-referencing-type-parameters">Mutually referencing type parameters</h3>

<p>In the <a href="https://github.com/golang/proposal/blob/master/design/go2draft-contracts.md">Go Contracts Proposal</a> there is an example of generic types / functions
with <a href="https://github.com/golang/proposal/blob/master/design/go2draft-contracts.md#mutually-referencing-type-parameters">mutually referencing type
parameters</a>
which involves a <code class="language-plaintext highlighter-rouge">graph</code> package defining a contract over two type parameters:
<code class="language-plaintext highlighter-rouge">Node</code> and <code class="language-plaintext highlighter-rouge">Edge</code>.  It can be expressed using package specialization as follows.
Note that the code is valid Go already!</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">graph</span>

<span class="k">type</span> <span class="n">Node</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Edges</span><span class="p">()</span> <span class="p">[]</span><span class="n">Edge</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Edge</span> <span class="n">interace</span> <span class="p">{</span>
    <span class="n">Nodes</span><span class="p">()</span> <span class="p">(</span><span class="n">from</span> <span class="n">Node</span><span class="p">,</span> <span class="n">to</span> <span class="n">Node</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Graph</span> <span class="k">struct</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">g</span> <span class="o">*</span><span class="n">Graph</span><span class="p">)</span> <span class="n">ShortestPath</span><span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">to</span> <span class="n">Node</span><span class="p">)</span> <span class="p">[]</span><span class="n">Edge</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="c">// For reference, the contract proposal implements this package as follows:</span>
<span class="c">//</span>
<span class="c">// contract G(Node, Edge) {</span>
<span class="c">// 	Node Edges() []Edge</span>
<span class="c">// 	Edge Nodes() (from Node, to Node)</span>
<span class="c">// }</span>

<span class="c">// type Graph(type Node, Edge G) struct { ... }</span>
<span class="c">// func New(type Node, Edge G)(nodes []Node) *Graph(Node, Edge) { ... }</span>
<span class="c">// func (g *Graph(Node, Edge)) ShortestPath(from, to Node) []Edge { ... }</span>
</code></pre></div></div>

<p>This package can then be used as follows in another package</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Vertex</span> <span class="k">struct</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">v</span> <span class="o">*</span><span class="n">Vertex</span><span class="p">)</span> <span class="n">Edges</span><span class="p">()</span> <span class="p">[]</span><span class="o">*</span><span class="n">FromTo</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">type</span> <span class="n">FromTo</span> <span class="k">struct</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">ft</span> <span class="o">*</span><span class="n">FromTo</span><span class="p">)</span> <span class="n">Nodes</span><span class="p">()</span> <span class="p">(</span><span class="o">*</span><span class="n">Vertex</span><span class="p">,</span> <span class="o">*</span><span class="n">Vertex</span><span class="p">)</span> <span class="p">{</span> <span class="o">...</span> <span class="p">}</span>

<span class="k">var</span> <span class="n">g</span> <span class="o">=</span> <span class="n">graph</span><span class="p">(</span><span class="n">Node</span><span class="o">=*</span><span class="n">Vertex</span><span class="p">,</span> <span class="n">Edge</span><span class="o">=*</span><span class="n">FromTo</span><span class="p">)</span><span class="o">.</span><span class="n">New</span><span class="p">([]</span><span class="o">*</span><span class="n">Vertex</span><span class="p">)</span>

<span class="c">// In the contract proposal, this is how you instanciate a graph:</span>
<span class="c">//</span>
<span class="c">// var g = graph.New(*Vertex, *FromTo)([]*Vertex{ ... })</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="go" /><category term="generics" /><summary type="html"><![CDATA[This is a follow-up to my inital post about Go Generics. In this post I attempt to scale back the approach outlined there to be the simplest possible while still providing the full power of parametrized code, and sketch the semantics more precisely. The problem space I’m trying to explore remains the same, which is to use interfaces as a means to write generic code in Go.]]></summary></entry><entry><title type="html">Setting up KaTeX in Jekyll</title><link href="/marooned/katex/jekyll/2020/05/25/test-maths.html" rel="alternate" type="text/html" title="Setting up KaTeX in Jekyll" /><published>2020-05-25T21:15:14+01:00</published><updated>2020-05-25T21:15:14+01:00</updated><id>/marooned/katex/jekyll/2020/05/25/test-maths</id><content type="html" xml:base="/marooned/katex/jekyll/2020/05/25/test-maths.html"><![CDATA[<p><a href="https://katex.org"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>KaTeX</mtext></mrow><annotation encoding="application/x-tex">\KaTeX</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.89883em;vertical-align:-0.2155em;"></span><span class="mord text"><span class="mord textrm">K</span><span class="mspace" style="margin-right:-0.17em;"></span><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.68333em;"><span style="top:-2.904999em;"><span class="pstrut" style="height:2.7em;"></span><span class="mord"><span class="mord textrm mtight sizing reset-size6 size3">A</span></span></span></span></span></span><span class="mspace" style="margin-right:-0.15em;"></span><span class="mord text"><span class="mord textrm">T</span><span class="mspace" style="margin-right:-0.1667em;"></span><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.46782999999999997em;"><span style="top:-2.7845em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord textrm">E</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2155em;"><span></span></span></span></span><span class="mspace" style="margin-right:-0.125em;"></span><span class="mord textrm">X</span></span></span></span></span></span></a> is great, so that’s what I
thought of first of using for displaying mathematical expressions when setting
up these pages. However I don’t know anything about Jekyll at all, so it could
have been a challenge…</p>

<p>I’m setting up <a href="https://github.com/linjer/jekyll-katex">jekyll-katex</a> and this
post is both to test that it works on github-pages and to share how I set it up.
It seems very nice and easy enough to set up!  The only trouble I had was
finding how to add the KaTeX css to the header.  In the end I used <a href="https://jekyllrb.com/docs/themes/#overriding-theme-defaults">these
instructions</a> to
copy the <code class="language-plaintext highlighter-rouge">_includes/head.html</code> default file for the <code class="language-plaintext highlighter-rouge">minima</code> theme into my
<code class="language-plaintext highlighter-rouge">_includes</code> directory (which I created for the occasion!), then added this line
to the <code class="language-plaintext highlighter-rouge">&lt;head&gt;</code> section of the file:</p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="nt">&lt;link</span> <span class="na">rel=</span><span class="s">"stylesheet"</span> <span class="na">href=</span><span class="s">"https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css"</span> <span class="na">integrity=</span><span class="s">"sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq"</span> <span class="na">crossorigin=</span><span class="s">"anonymous"</span><span class="nt">&gt;</span>
</code></pre></div></div>
<p>This is my resulting <a href="https://github.com/arnodel/arnodel.github.io/tree/master/src/_includes/head.html"><code class="language-plaintext highlighter-rouge">src/_includes/head.html</code></a>.</p>

<p>Many thanks to the author of this plugin!</p>

<p>The problem is that the plugin is not supported by github-pages.  So I guess for
now I will have to build my site locally.  That means moving the whole source
code for the Jekyll site to <code class="language-plaintext highlighter-rouge">src/</code>, building locally into <code class="language-plaintext highlighter-rouge">marooned/</code>, adding a
<code class="language-plaintext highlighter-rouge">.nojekyll</code> file to the root so that Github doesn’t try to build it itself.
Thanks Github!  This is the price to pay for being able to render maths
server-side it seems.</p>

<p>There seems to be a way to use a Travis Job circumvent this issue
<a href="https://stackoverflow.com/a/51454606/2380495">here</a>. Perhaps I will set that up
later, as this means I need to remember to build the site before each commit!.</p>

<p>The examples below are copy-pasted from the jekyll-katex readme.</p>

<p>Some inline maths: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mo>±</mo><msqrt><mrow><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><msup><mi>b</mi><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">
c = \pm\sqrt{a^2 + b^2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.12661100000000003em;"></span><span class="mord">±</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.913389em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.873389em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12661100000000003em;"><span></span></span></span></span></span></span></span></span></p>

<p>Some display maths:
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mo>±</mo><msqrt><mrow><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><msup><mi>b</mi><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">
c = \pm\sqrt{a^2 + b^2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2399999999999998em;vertical-align:-0.177736em;"></span><span class="mord">±</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.0622639999999999em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.0222640000000003em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg width="400em" height="1.28em" viewBox="0 0 400000 1296" preserveAspectRatio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119 c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120 c340,-704.7,510.7,-1060.3,512,-1067 l0 -0 c4.7,-7.3,11,-11,19,-11 H40000v40H1012.3 s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232 c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1 s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26 c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z M1001 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.177736em;"><span></span></span></span></span></span></span></span></span></span></p>

<p>This is a mixed environment where you can have normal text and <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>=</mo><mo>±</mo><msqrt><mrow><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><msup><mi>b</mi><mn>2</mn></msup></mrow></msqrt></mrow><annotation encoding="application/x-tex">c = \pm\sqrt{a^2 + b^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.12661100000000003em;"></span><span class="mord">±</span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.913389em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.873389em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width="400em" height="1.08em" viewBox="0 0 400000 1080" preserveAspectRatio="xMinYMin slice"><path d="M95,702 c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 l0 -0 c5.3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.12661100000000003em;"><span></span></span></span></span></span></span></span></span> fenced math. $!</p>]]></content><author><name></name></author><category term="katex" /><category term="jekyll" /><summary type="html"><![CDATA[KaTeX\KaTeXKATE​X is great, so that’s what I thought of first of using for displaying mathematical expressions when setting up these pages. However I don’t know anything about Jekyll at all, so it could have been a challenge…]]></summary></entry><entry><title type="html">An approach for Go Generics</title><link href="/marooned/go/generics/2020/05/25/go-spec.html" rel="alternate" type="text/html" title="An approach for Go Generics" /><published>2020-05-25T18:13:14+01:00</published><updated>2020-05-25T18:13:14+01:00</updated><id>/marooned/go/generics/2020/05/25/go-spec</id><content type="html" xml:base="/marooned/go/generics/2020/05/25/go-spec.html"><![CDATA[<p>This is not a proposal, rather outlining a different approach to achieve
“generics” in Go.  I see a problem with the existing proposal in that it
duplicates Go interfaces to some extent.  It’s a shame in my opinion, as so far
Go has been very careful to be a language with orthogonal (i.e. non-overlapping)
features. I am trying to address this problem by adding generics to the language
<em>using interfaces</em>.</p>

<h2 id="a-generic-graph-package-with-interfaces">A “generic” <code class="language-plaintext highlighter-rouge">graph</code> package with interfaces</h2>

<p>The first non-trivial example of the Go Contract proposal is a <a href="https://github.com/golang/proposal/blob/master/design/go2draft-contracts.md#mutually-referencing-type-parameters">graph
contract</a>
so I am using a similar example. Say we have a <code class="language-plaintext highlighter-rouge">graph</code> package defining the
following:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">graph</span>

<span class="k">type</span> <span class="n">N</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Edges</span><span class="p">()</span> <span class="p">[]</span><span class="n">E</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">E</span> <span class="k">interface</span> <span class="p">{</span>
    <span class="n">Nodes</span><span class="p">()</span> <span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Graph</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">nodes</span> <span class="p">[]</span><span class="n">N</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewGraph</span><span class="p">(</span><span class="n">nodes</span> <span class="p">[]</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span><span class="n">Graph</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">Graph</span><span class="p">{</span><span class="n">nodes</span><span class="o">:</span> <span class="n">nodes</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Neighbors</span><span class="p">(</span><span class="n">n</span> <span class="n">N</span><span class="p">)</span> <span class="p">[]</span><span class="n">N</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">neighbors</span> <span class="p">[]</span><span class="n">N</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">n</span><span class="o">.</span><span class="n">Edges</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">:=</span> <span class="n">e</span><span class="o">.</span><span class="n">Nodes</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">n1</span> <span class="o">!=</span> <span class="n">n</span> <span class="p">{</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">n1</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">n2</span> <span class="o">!=</span> <span class="n">n</span> <span class="p">{</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">neighbors</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It is “generic” insofar as it doesn’t rely on a particular implementation of the
node <code class="language-plaintext highlighter-rouge">N</code> interface and the edge <code class="language-plaintext highlighter-rouge">E</code> interface, but of course as Go currently
stands it suffers from all the problems that the Go generics proposals are
trying to solve. To define these problems more precisely, let’s try to use the
package above.</p>

<h2 id="issues-with-the-graph-package">Issues with the <code class="language-plaintext highlighter-rouge">graph</code> package</h2>

<p>Say we have another package <code class="language-plaintext highlighter-rouge">mygraph</code> in which we want to implement a graph
using the <code class="language-plaintext highlighter-rouge">graph.Graph</code> type but with a specialized type for <code class="language-plaintext highlighter-rouge">N</code> and <code class="language-plaintext highlighter-rouge">E</code>:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">mygraph</span>

<span class="k">type</span> <span class="n">Node</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">edges</span> <span class="p">[]</span><span class="o">*</span><span class="n">Edge</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="n">Edges</span> <span class="p">[]</span><span class="o">*</span><span class="n">Edge</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">edges</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Edge</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">*</span><span class="n">Node</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">e</span> <span class="o">*</span><span class="n">Edge</span><span class="p">)</span> <span class="n">Nodes</span> <span class="p">(</span><span class="o">*</span><span class="n">Node</span><span class="p">,</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">e</span><span class="o">.</span><span class="n">n1</span><span class="p">,</span> <span class="n">e</span><span class="o">.</span><span class="n">n2</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If we want to make use of the <code class="language-plaintext highlighter-rouge">graph.Graph</code> type and the <code class="language-plaintext highlighter-rouge">graph.Neighbors</code>
functions, several problems arise.</p>

<ul>
  <li><strong>Type safety</strong>. The compiler cannot ensure that only instances of <code class="language-plaintext highlighter-rouge">*Node</code> will be
in our graph instance, as any type that implements <code class="language-plaintext highlighter-rouge">graph.N</code> will satisfy the
type constraints.</li>
  <li><strong>Performance</strong>. All our instances of <code class="language-plaintext highlighter-rouge">*Node</code> and <code class="language-plaintext highlighter-rouge">*Edge</code> will be wrapped in an
interface, which will incur a small performance penalty. It also follows from
this that there will be no opportunity for the compiler to optimise the code
in the <code class="language-plaintext highlighter-rouge">graph</code> package for the particular <code class="language-plaintext highlighter-rouge">*Node</code> and <code class="language-plaintext highlighter-rouge">*Edge</code> implementations
of the <code class="language-plaintext highlighter-rouge">graph.N</code> and <code class="language-plaintext highlighter-rouge">graph.E</code> interfaces.</li>
  <li><strong>Boilerplate</strong>. it will be necessary to convert between interface and concrete
type continually in the code using <code class="language-plaintext highlighter-rouge">graph</code>, and also between slice types, e.g.
<code class="language-plaintext highlighter-rouge">[]*Node</code> and <code class="language-plaintext highlighter-rouge">[]graph.N</code>.</li>
</ul>

<h2 id="specialization-as-a-means-to-remedy-these-issues">Specialization as a means to remedy these issues</h2>

<p>We introduce the idea of <em>specialization</em>. A specialization can be seen as a
mapping from Go package-level identifiers to compile-time defined values (e.g.
types, functions, constants). The new keyword <code class="language-plaintext highlighter-rouge">spec</code> will allow us to defined
specializations.</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// in package mygraph</span>

<span class="n">spec</span> <span class="n">GraphSpec</span> <span class="p">{</span>
    <span class="k">type</span> <span class="n">N</span> <span class="o">=</span> <span class="o">*</span><span class="n">Node</span> <span class="c">// The identifier N maps to the *Node type</span>
    <span class="k">type</span> <span class="n">E</span> <span class="o">=</span> <span class="o">*</span><span class="n">Edge</span> <span class="c">// The identifier E maps to the *Edge type</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This defines the <code class="language-plaintext highlighter-rouge">GraphSpec</code> specialization. This specialization can then be
<em>applied</em> to package level types, functions, or even whole packages. A
specialization is applied by replacing the definitions of the identifiers named
in it with the value they are defined as in the target package. Here are some
examples, all supposed to be defined in the <code class="language-plaintext highlighter-rouge">mygraph</code> package.</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// import "graph"</span>

<span class="k">type</span> <span class="n">Graph</span> <span class="o">=</span> <span class="n">GraphSpec</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">Graph</span><span class="p">)</span>
</code></pre></div></div>

<p>This is equivalent to defining</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Graph</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">nodes</span> <span class="p">[]</span><span class="o">*</span><span class="n">Node</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Or:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Neighbors</span> <span class="o">=</span> <span class="n">GraphSpec</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">Neighbors</span><span class="p">)</span>
</code></pre></div></div>

<p>This is equivalent to defining</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">Neighbors</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="p">[]</span><span class="o">*</span><span class="n">Node</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">neighbors</span> <span class="p">[]</span><span class="o">*</span><span class="n">Node</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">e</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">n</span><span class="o">.</span><span class="n">Edges</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">:=</span> <span class="n">e</span><span class="o">.</span><span class="n">Nodes</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">n1</span> <span class="o">!=</span> <span class="n">n</span> <span class="p">{</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">n1</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">n2</span> <span class="o">!=</span> <span class="n">n</span> <span class="p">{</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">neighbors</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">neighbors</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Or even perhaps</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GraphSpec</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
</code></pre></div></div>

<p>This would be equivalent to “reimplementing” the whole of the <code class="language-plaintext highlighter-rouge">graph</code> package in
he current <code class="language-plaintext highlighter-rouge">mygraph</code> package, so we would have the following defined in the
<code class="language-plaintext highlighter-rouge">mygraph</code> package:</p>

<div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">Graph</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">nodes</span> <span class="p">[]</span><span class="n">Node</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">NewGraph</span><span class="p">(</span><span class="n">nodes</span> <span class="p">[]</span><span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="o">*</span><span class="n">Graph</span> <span class="p">{</span>
    <span class="c">// ...</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Neighbors</span><span class="p">(</span><span class="n">n</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="p">[]</span><span class="o">*</span><span class="n">Node</span> <span class="p">{</span>
    <span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="to-be-continued">To be continued!</h2>

<p>I’m hoping to have some time to think this trough at some point!  If you think
this is a promising idea, please get in touch with me.</p>]]></content><author><name></name></author><category term="go" /><category term="generics" /><summary type="html"><![CDATA[This is not a proposal, rather outlining a different approach to achieve “generics” in Go. I see a problem with the existing proposal in that it duplicates Go interfaces to some extent. It’s a shame in my opinion, as so far Go has been very careful to be a language with orthogonal (i.e. non-overlapping) features. I am trying to address this problem by adding generics to the language using interfaces.]]></summary></entry></feed>